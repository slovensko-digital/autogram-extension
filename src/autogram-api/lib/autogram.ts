/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/info": {
    /** Retrieve info and the current server status */
    get: operations["getInfo"];
  };
  "/sign": {
    /** Sign a single document */
    post: operations["signDocument"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    Info: {
      /** @example 1.2.3 */
      version?: string;
      /** @enum {string} */
      status?: "LOADING" | "READY";
    };
    SignRequestBody: {
      document: components["schemas"]["Document"];
      parameters: components["schemas"]["SignatureParameters"];
      /**
       * @description MIME type for document content and signature parameters like transformation and schema.
       * Binary files should be encoded using base64, e.g., `application/pdf;base64`.
       * Text formats like XML can be optionally encoded using base64 but can be supplied as plain text as seen in the examples, in which case the type is `application/xml`.
       *  
       * @example application/xml
       */
      payloadMimeType: string;
      /**
       * @description Base64 encoded HMAC-SHA512 of the nonce and body that is required if the server was launched with the optional secret key.
       * You should encode the body prepared for sending and create its HMAC-SHA512 before encoding it again with this property.
       * 
       * Example:
       * 
       * 0. Serialize the request body `body = serialize(payload)`.
       * 1. Calculate the SHA256 of the concatenated nonce and body `hash = sha256(nonce + body)`.
       * 2. Calculate the HMAC of the URI path and query and the prepared hash using the agreed on secret key `hmac = hmac-512(/sign?template=lorem + hash, key)`.
       * 3. Serialize the request body again, but this time with the calculated additional `hmac` property.
       * 4. Increase the nonce if the request succeeded.
       */
      hmac?: string;
    };
    Document: {
      /**
       * @description Filename of the original file to be signed. Is used inside ASiC container. 
       * @example document.xml
       */
      filename?: string;
      /**
       * @description Content of the document to sign, format is dictated by `payloadMimeType`. 
       * @example <?xml version="1.0"?><Document><Title>Lorem Ipsum</Title></Document>
       */
      content: string;
    };
    SignResponseBody: {
      /**
       * @description Signed content of the original document - either in plaintext or in Base64 format. 
       * @example TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvQDSdd57FueSBoYW5kcyBtYWtlIGxpZ2h0IHdvsRWdaAeSBoYW5kcyBtYW==
       */
      content: string;
      /**
       * @description Distinguished name of the certificate used/attempting to sign the document. 
       * @example SERIALNUMBER=PNOSK-1234567890, C=SK, L=Bratislava, SURNAME=Smith, GIVENNAME=John, CN=John Smith
       */
      signedBy: string;
      /**
       * @description Distinguished name of the issuer of the certificate used/attempting to sign the document. 
       * @example CN=SVK eID ACA2, O=Disig a.s., OID.2.5.4.97=NTRSK-12345678, L=Bratislava, C=SK
       */
      issuedBy: string;
    };
    SignatureParameters: {
      /**
       * @description Signature format PAdES is usable only with documents of type `application/pdf`. Format XAdES is usable with XML or with any file type if using an ASiC container. 
       * @example XAdES_BASELINE_B 
       * @enum {string}
       */
      form: "XAdES_BASELINE_B" | "XAdES_BASELINE_T" | "XAdES_BASELINE_LT" | "XAdES_BASELINE_LTA" | "PAdES_BASELINE_B" | "PAdES_BASELINE_T" | "PAdES_BASELINE_LT" | "PAdES_BASELINE_LTA" | "CAdES_BASELINE_B" | "CAdES_BASELINE_T" | "CAdES_BASELINE_LT" | "CAdES_BASELINE_LTA";
      /**
       * @description Optional container type that should be used to place the file with signature to. 
       * @example ASiC_E 
       * @enum {string}
       */
      container?: "ASiC_S" | "ASiC_E";
      /**
       * @description XML namespace for the ASiC container. 
       * @example http://data.gov.sk/def/container/xmldatacontainer+xml/1.1
       */
      containerXmlns?: string;
      /**
       * @description Optional identifier of the document template. 
       * @example https://data.gov.sk/id/egov/eform/App.GeneralAgenda/1.9
       */
      identifier?: string;
      /**
       * @description Optional form of packaging used with XML. ENVELOPED adds the signature as a child of the root element while ENVELOPING wraps the XML in a new element. Defaults to ENVELOPED. 
       * @example ENVELOPED 
       * @enum {string}
       */
      packaging?: "ENVELOPED" | "ENVELOPING";
      /**
       * @description Optional algorithm used to calculate digests. Defaults to SHA256. 
       * @example SHA256 
       * @enum {string}
       */
      digestAlgorithm?: "SHA256" | "SHA384" | "SHA512";
      /**
       * @description Optional flag to control whether the signature should be made according to EN 319132. Defaults to true. 
       * @example false
       */
      en319132?: boolean;
      /**
       * @description Optional info canonicalization method. 
       * @example INCLUSIVE 
       * @enum {string}
       */
      infoCanonicalization?: "INCLUSIVE" | "EXCLUSIVE" | "INCLUSIVE_WITH_COMMENTS" | "EXCLUSIVE_WITH_COMMENTS" | "INCLUSIVE_11" | "INCLUSIVE_11_WITH_COMMENTS";
      /**
       * @description Optional properties canonicalization method. 
       * @example INCLUSIVE 
       * @enum {string}
       */
      propertiesCanonicalization?: "INCLUSIVE" | "EXCLUSIVE" | "INCLUSIVE_WITH_COMMENTS" | "EXCLUSIVE_WITH_COMMENTS" | "INCLUSIVE_11" | "INCLUSIVE_11_WITH_COMMENTS";
      /**
       * @description Optional key info canonicalization method. 
       * @example INCLUSIVE 
       * @enum {string}
       */
      keyInfoCanonicalization?: "INCLUSIVE" | "EXCLUSIVE" | "INCLUSIVE_WITH_COMMENTS" | "EXCLUSIVE_WITH_COMMENTS" | "INCLUSIVE_11" | "INCLUSIVE_11_WITH_COMMENTS";
      /**
       * @description Optional XML schema. Format is dictated by `payloadMimeType`. 
       * @example <?xml version="1.0"?><xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"><xs:element name="Document"><xs:complexType><xs:sequence><xs:element name="Title" type="xs:string" /></xs:sequence></xs:complexType></xs:element></xs:schema>
       */
      schema?: string;
      /**
       * @description Optional XML transformation. Format is dictated by `payloadMimeType`. 
       * @example <?xml version="1.0"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"><xsl:template match = "/"><h1><xsl:value-of select="/Document/Title"/></h1></xsl:template></xsl:stylesheet>
       */
      transformation?: string;
    };
    ErrorBody: {
      /**
       * @description Code that can be used to identify the error. 
       * @example MALFORMED_INPUT 
       * @enum {string}
       */
      code?: "NOT_READY" | "UNSUPPORTED_OPERATION" | "MALFORMED_INPUT" | "UNSUPPORTED_FORMAT" | "SIGNING_FAILED" | "UNEXPECTED_ORIGIN" | "UNEXPECTED_ERROR";
      /**
       * @description Mostly human readable error message. 
       * @example Malformed input body.
       */
      message?: string;
      /**
       * @description Optional details, likely not human readable, like raw exception message. 
       * @example Unable to switch to fourth dimension: java.lang.NullPointerException
       */
      details?: string;
    };
    UserCancelledBody: {
      /**
       * @description Code that can be used to identify the error. 
       * @example USER_CANCELLED 
       * @enum {string}
       */
      code?: "USER_CANCELLED";
      /**
       * @description Mostly human readable error message. 
       * @example User cancelled the signing process.
       */
      message?: string;
      /**
       * @description Optional details, likely not human readable, like raw exception message. 
       * @example User cancelled the signing process.
       */
      details?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  /** Retrieve info and the current server status */
  getInfo: {
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["Info"];
        };
      };
      /** @description Request came from an unexpected origin. */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorBody"];
        };
      };
      /** @description Incorrect HTTP method. */
      405: {
        content: {
          "application/json": components["schemas"]["ErrorBody"];
        };
      };
      /** @description Request failed due to some unexpected error. */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorBody"];
        };
      };
    };
  };
  /** Sign a single document */
  signDocument: {
    requestBody: {
      content: {
        "*/*": components["schemas"]["SignRequestBody"];
      };
    };
    responses: {
      /** @description The document was successfully signed and its content is available in the response body. */
      200: {
        content: {
          "application/json": components["schemas"]["SignResponseBody"];
        };
      };
      /** @description The document was not signed because the user cancelled the signing process. */
      204: {
        content: {
          "application/json": components["schemas"]["UserCancelledBody"];
        };
      };
      /** @description The request body cannot be processed. */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorBody"];
        };
      };
      /** @description Request came from an unexpected origin. */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorBody"];
        };
      };
      /** @description Incorrect HTTP method. */
      405: {
        content: {
          "application/json": components["schemas"]["ErrorBody"];
        };
      };
      /** @description Server is not ready to process the request. */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorBody"];
        };
      };
      /** @description Request failed due to some unexpected error. */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorBody"];
        };
      };
    };
  };
}
