/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/documents": {
    /**
     * Client app posts document along with some parameters to Server.
     * @description Client app posts document along with some parameters to Server. Server encrypts the document using the provided EncryptionKey and stores it on a disk.
     */
    post: {
      parameters: {
        header: {
          Accept: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": components["schemas"]["DocumentPostRequestBody"];
        };
      };
      responses: {
        /** @description Server stored the data and returned GUID so the client can further access the data. */
        200: {
          headers: {
            /** @description Datetime of the last-modified attribute of the uploaded file. Useful for polling with the GET document request. */
            "Last-Modified"?: string;
          };
          content: {
            "application/json": components["schemas"]["CreateDocumentResponseBody"];
          };
        };
        /** @description Bad request */
        400: {
          content: {
            "application/json": components["schemas"]["BadRequestErrorResponseBody"];
          };
        };
        /** @description EncryptionKey not provided */
        401: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyNotProvidedErrorResponseBody"];
          };
        };
        /** @description Unprocessable content */
        422: {
          content: {
            "application/json": components["schemas"]["ErrorResponseBody"];
          };
        };
        /** @description Internal error */
        500: {
          content: {
            "application/json": components["schemas"]["InternalErrorResponseBody"];
          };
        };
        /** @description Bad gateway - internal error on AVM microservice */
        502: {
          content: {
            "application/json": components["schemas"]["BadGatewayErrorResponseBody"];
          };
        };
      };
    };
  };
  "/documents/{guid}": {
    /**
     * External system requests signed document at the end of the process.
     * @description This endpoint is also designed for polling with the `If-Modified-Since` header.
     */
    get: {
      parameters: {
        header: {
          "If-Modified-Since"?: string;
          Accept: string;
        };
        path: {
          /** @example bfde97b4-ee27-47bc-97e2-5164ed96a92a */
          guid: string;
        };
      };
      responses: {
        /** @description Requested document with an array of its signers */
        200: {
          headers: {
            /** @description Datetime of the last-modified attribute of the requeste document. */
            "Last-Modified"?: string;
          };
          content: {
            "application/json": components["schemas"]["GetDocumentResponseBody"];
          };
        };
        /** @description Requested document has not been modified since `If-Modified-Since` header */
        304: {
          headers: {
            /** @description Datetime of the last-modified attribute of the requeste document. */
            "Last-Modified"?: string;
          };
          content: never;
        };
        /** @description Bad request */
        400: {
          content: {
            "application/json": components["schemas"]["BadRequestErrorResponseBody"];
          };
        };
        /** @description EncryptionKey not provided */
        401: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyNotProvidedErrorResponseBody"];
          };
        };
        /** @description EncryptionKey mismatch */
        403: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyMismatchErrorResponseBody"];
          };
        };
        /** @description Not found */
        404: {
          content: never;
        };
        /** @description Unprocessable content */
        422: {
          content: {
            "application/json": components["schemas"]["ErrorResponseBody"];
          };
        };
        /** @description Internal error */
        500: {
          content: {
            "application/json": components["schemas"]["InternalErrorResponseBody"];
          };
        };
        /** @description Bad gateway - internal error on AVM microservice */
        502: {
          content: {
            "application/json": components["schemas"]["BadGatewayErrorResponseBody"];
          };
        };
      };
    };
    /**
     * External system requests signed document at the end of the process.
     * @description This endpoint is also designed for polling with the `If-Modified-Since` header.
     */
    delete: {
      parameters: {
        path: {
          /** @example aedf97b4-ee27-47bc-97e2-5164ed96a92a */
          guid: string;
        };
      };
      responses: {
        /** @description Document deleted */
        204: {
          content: never;
        };
        /** @description Bad request */
        400: {
          content: {
            "application/json": components["schemas"]["BadRequestErrorResponseBody"];
          };
        };
        /** @description EncryptionKey not provided */
        401: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyNotProvidedErrorResponseBody"];
          };
        };
        /** @description EncryptionKey mismatch */
        403: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyMismatchErrorResponseBody"];
          };
        };
        /** @description Not found */
        404: {
          content: never;
        };
        /** @description Unprocessable content */
        422: {
          content: {
            "application/json": components["schemas"]["ErrorResponseBody"];
          };
        };
        /** @description Internal error */
        500: {
          content: {
            "application/json": components["schemas"]["InternalErrorResponseBody"];
          };
        };
        /** @description Bad gateway - internal error on AVM microservice */
        502: {
          content: {
            "application/json": components["schemas"]["BadGatewayErrorResponseBody"];
          };
        };
      };
    };
  };
  "/documents/{guid}/visualization": {
    /** Client app requests encrypted document to visualize it. */
    get: {
      parameters: {
        header: {
          Accept: string;
        };
        path: {
          /** @example bfde97b4-ee27-47bc-97e2-5164ed96a92a */
          guid: string;
        };
      };
      responses: {
        /** @description OK */
        200: {
          content: {
            "application/json": components["schemas"]["DocumentVisualizationResponseBody"];
          };
        };
        /** @description Bad request */
        400: {
          content: {
            "application/json": components["schemas"]["BadRequestErrorResponseBody"];
          };
        };
        /** @description EncryptionKey not provided */
        401: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyNotProvidedErrorResponseBody"];
          };
        };
        /** @description EncryptionKey mismatch */
        403: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyMismatchErrorResponseBody"];
          };
        };
        /** @description Not found */
        404: {
          content: never;
        };
        /** @description Unprocessable content */
        422: {
          content: {
            "application/json": components["schemas"]["ErrorResponseBody"];
          };
        };
        /** @description Internal error */
        500: {
          content: {
            "application/json": components["schemas"]["InternalErrorResponseBody"];
          };
        };
        /** @description Bad gateway - internal error on AVM microservice */
        502: {
          content: {
            "application/json": components["schemas"]["BadGatewayErrorResponseBody"];
          };
        };
      };
    };
  };
  "/documents/{guid}/parameters": {
    /** Client app gets the signature parameters of the doucment */
    get: {
      parameters: {
        header: {
          Accept: string;
        };
        path: {
          /** @example bfde97b4-ee27-47bc-97e2-5164ed96a92a */
          guid: string;
        };
      };
      responses: {
        /** @description OK */
        200: {
          content: {
            "application/json": components["schemas"]["SigningParameters"];
          };
        };
        /** @description EncryptionKey not provided */
        401: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyNotProvidedErrorResponseBody"];
          };
        };
        /** @description EncryptionKey mismatch */
        403: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyMismatchErrorResponseBody"];
          };
        };
        /** @description Not found */
        404: {
          content: never;
        };
      };
    };
  };
  "/documents/{guid}/validation": {
    /** Client app requests a signature validation report of the document. */
    get: {
      parameters: {
        header: {
          Accept: string;
        };
        path: {
          /** @example bfde97b4-ee27-47bc-97e2-5164ed96a92a */
          guid: string;
        };
      };
      responses: {
        /** @description Validation report */
        200: {
          content: {
            "application/json": components["schemas"]["DocumentValidationResponseBody"];
          };
        };
        /** @description Document is not signed yet, no content response. */
        204: {
          content: never;
        };
        /** @description Bad request */
        400: {
          content: {
            "application/json": components["schemas"]["BadRequestErrorResponseBody"];
          };
        };
        /** @description EncryptionKey not provided */
        401: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyNotProvidedErrorResponseBody"];
          };
        };
        /** @description EncryptionKey mismatch */
        403: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyMismatchErrorResponseBody"];
          };
        };
        /** @description Not found */
        404: {
          content: never;
        };
        /** @description Unprocessable content */
        422: {
          content: {
            "application/json": components["schemas"]["ErrorResponseBody"];
          };
        };
        /** @description Internal error */
        500: {
          content: {
            "application/json": components["schemas"]["InternalErrorResponseBody"];
          };
        };
        /** @description Bad gateway - internal error on AVM microservice */
        502: {
          content: {
            "application/json": components["schemas"]["BadGatewayErrorResponseBody"];
          };
        };
      };
    };
  };
  "/documents/{guid}/datatosign": {
    /**
     * Client app gets datatosign based on provided signing certificate.
     * @description Client app posts signing certificate to the server. Server decrypts the encrypted document from disk, computes DataToSign and returns it along exact signing time in milliseconds. The whole response object is later required for POST /sign request.
     */
    post: {
      parameters: {
        header: {
          Accept: string;
        };
        path: {
          /** @example bfde97b4-ee27-47bc-97e2-5164ed96a92a */
          guid: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": components["schemas"]["DataToSignRequestBody"];
        };
      };
      responses: {
        /** @description Computed DataToSign and exact SigningTime. */
        200: {
          content: {
            "application/json": components["schemas"]["DataToSignStructure"];
          };
        };
        /** @description Bad request */
        400: {
          content: {
            "application/json": components["schemas"]["BadRequestErrorResponseBody"];
          };
        };
        /** @description EncryptionKey not provided */
        401: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyNotProvidedErrorResponseBody"];
          };
        };
        /** @description EncryptionKey mismatch */
        403: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyMismatchErrorResponseBody"];
          };
        };
        /** @description Not found */
        404: {
          content: never;
        };
        /** @description Unprocessable content */
        422: {
          content: {
            "application/json": components["schemas"]["ErrorResponseBody"];
          };
        };
        /** @description Internal error */
        500: {
          content: {
            "application/json": components["schemas"]["InternalErrorResponseBody"];
          };
        };
        /** @description Bad gateway - internal error on AVM microservice */
        502: {
          content: {
            "application/json": components["schemas"]["BadGatewayErrorResponseBody"];
          };
        };
      };
    };
  };
  "/documents/{guid}/sign": {
    /** Create signed document using the SignedData obtained from client. */
    post: {
      parameters: {
        query?: {
          returnSignedDocument?: boolean;
        };
        header: {
          Accept: string;
        };
        path: {
          /** @example bfde97b4-ee27-47bc-97e2-5164ed96a92a */
          guid: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": components["schemas"]["SignRequestBody"];
        };
      };
      responses: {
        /**
         * @description Document was sucessfuly signed, can be obtained via GET signed request, and is also returned in the response.
         *
         * When `"returnSignedDocument": false` Document.Content is empty.
         */
        200: {
          content: {
            "application/json": components["schemas"]["SignDocumentResponseBody"];
          };
        };
        /** @description Bad request */
        400: {
          content: {
            "application/json": components["schemas"]["BadRequestErrorResponseBody"];
          };
        };
        /** @description EncryptionKey not provided */
        401: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyNotProvidedErrorResponseBody"];
          };
        };
        /** @description EncryptionKey mismatch */
        403: {
          content: {
            "application/json": components["schemas"]["EncryptionKeyMismatchErrorResponseBody"];
          };
        };
        /** @description Not found */
        404: {
          content: never;
        };
        /** @description Signature invalid */
        409: {
          content: {
            "application/json": components["schemas"]["InvalidSignatureErrorResponseBody"];
          };
        };
        /** @description Unprocessable content */
        422: {
          content: {
            "application/json": components["schemas"]["ErrorResponseBody"];
          };
        };
        /** @description Internal error */
        500: {
          content: {
            "application/json": components["schemas"]["InternalErrorResponseBody"];
          };
        };
        /** @description Bad gateway - internal error on AVM microservice */
        502: {
          content: {
            "application/json": components["schemas"]["BadGatewayErrorResponseBody"];
          };
        };
      };
    };
  };
  "/integrations": {
    /** Integration registers itself at the server */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["PostIntegrationRequestBody"];
        };
      };
      responses: {
        /** @description OK */
        200: {
          content: {
            "application/json": components["schemas"]["PostIntegrationResponse"];
          };
        };
      };
    };
  };
  "/devices": {
    /** Device registers itself at the server */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["PostDeviceRequestBody"];
        };
      };
      responses: {
        /** @description OK */
        200: {
          content: {
            "application/json": components["schemas"]["PostDeviceResponse"];
          };
        };
      };
    };
  };
  "/device-integrations": {
    /** Device retrieves a list of paired integrations */
    get: {
      responses: {
        /** @description OK */
        200: {
          content: {
            "application/json": components["schemas"]["GetDeviceIntegrationsResponseBody"];
          };
        };
      };
    };
    /** Device registers itself for receiving sign requests (push notification) from given integration */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["PostDeviceIntegrationsRequestBody"];
        };
      };
      responses: {
        /** @description OK */
        204: {
          content: never;
        };
      };
    };
  };
  "/device-integrations/{integration_id}": {
    /** Device deletes integration from its paired integrations */
    delete: {
      parameters: {
        path: {
          /**
           * @description Identifier of the integration
           * @example 0d939eb1-8e14-41e5-9c7e-05e77641cc7b
           */
          integration_id: string;
        };
      };
      responses: {
        /** @description OK */
        204: {
          content: never;
        };
        /** @description Not found */
        404: {
          content: never;
        };
      };
    };
  };
  "/integration-devices": {
    /** Integration retrieves a list of paired devices */
    get: {
      responses: {
        /** @description OK */
        200: {
          content: {
            "application/json": components["schemas"]["GetIntegrationDevicesResponseBody"];
          };
        };
      };
    };
  };
  "/integration-devices/{device_id}": {
    /** Integration deletes device from its paired devices */
    delete: {
      parameters: {
        path: {
          /**
           * @description Identifier of the device
           * @example 03de5319-a40d-48ea-b4fb-29d11e7017bb
           */
          device_id: string;
        };
      };
      responses: {
        /** @description OK */
        204: {
          content: never;
        };
        /** @description Not found */
        404: {
          content: never;
        };
      };
    };
  };
  "/sign-request": {
    /** Integration sends a sign request (push notification) to all paired signing devices */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["PostSignRequestBody"];
        };
      };
      responses: {
        /** @description OK */
        200: {
          content: never;
        };
      };
    };
  };
  "/qr-code": {
    /**
     * URL format used by Autogram extenision and Autogram v mobile app
     * @description This QR code / URL is a standard used by Autogram browser extension and Autogram v mobile application. Server doesn't really care if potential other integrations / applications use the same format or not.
     *
     * Example: `https://autogram.slovensko.digital/api/v1/qr-code?guid=e7e95411-66a1-d401-e063-0a64dbb6b796&key=EeESAfZQh9OTf5qZhHZtgaDJpYtxZD6TIOQJzRgRFgQ%3D&integration=eyJhbGciOiJFUzI1NiJ9.eyJzdWIiOiI3OGQ5MWRlNy0xY2MyLTQwZTQtOWE3MS0zODU4YjRmMDMxOWQiLCJleHAiOjE3MTI5MDk3MjAsImp0aSI6IjAwZTAxN2Y1LTI4MTAtNDkyNS04ODRlLWNiN2FhZDAzZDFhNiIsImF1ZCI6ImRldmljZSJ9.7Op6W2BvbX2_mgj9dkz1IiolEsQ1Z2a0AzpS5bj4pcG3CJ4Z8j9W3RQE95wrAj3t6nmd9JaGZSlCJNSV_myyLQ`
     *
     * <img src="data:image/png;base64, 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JEyPHj169OjRO8t5YRLoOaFNrb09PNbppekW7u2+8L3TVunRo0ePHj16sWe17yEUtWqBaO867mW1rVj1vqF32NksH6NHjx49evToXRahJsy9tlbPOATAw5Lc3pl7fpe/2N+jR48ePXr0frRe3f9eOKu5rD5qSnwvfeoG65Nr8LyPqvTo0aNHjx6980fvPnVmqVas9qmkmx7iTZuxdPCebxI9evTo0aNH73f/X6n3Nwr8lfCadU/WU0fwZuyqNEnp0aNHjx49er/7GE04sZAq66HW2lUV3Uton4nSh41TevTo0aNHj977A3weNLqZjK4+dci6ftvLczqcE5/Gs+rVoUePHj169Ohd6N0UeT54qNeVt1AFvPm9qcNYz4UePXr06NGjF1tYtQE3/bUORd909aa226R82Aw8bD3So0ePHj169GLKquWyPYyGE3sTv87aaXulrPp8+prQo0ePHj169JaQFLpcU71oL4iFp+yh9ebIp2sSkuZUM6NHjx49evToxXxZQ+bzqp258B2n0S2i1+LcVFXcO4L06NGjR48evVhmqgPBobL1HBT3Le3h8RDzZuc1UJ729+jRo0ePHr2v05uOt9ap9rmeWtSqsfmD+bf2Aaf24TZ7RY8ePXr06NE7ktrnhELAuumL7R8L51kTeK3f7YNL9OjRo0ePHr2lt7VP7hweTC2XTXeltuxCB6++2lQUzJVBevTo0aNH79v16stMouEA9z0c1r1qwt03vdfv9ktEjx49evTo0Vs2t9NMlyPE3BrxDnuSh5XB2svbO6D06NGjR48evdvMOSWqfU6oDjOFnDc15cLFum5qHoZlevTo0aNHj968DqtE0+nsjcTaWKtR8PmX98+GgmK+mfTo0aNHj9636+1BbEqGU4PwBjhUrGoY3VuUtbZW35QePXr06NGjF1t7h4d1U1ur537Y7pvy5eGV3fuFNW7So0ePHj169JbkNX37YXftcCZo/+X6lXufcq+KhS3Qo0ePHj169Ga9vXw0dc2m87z+6c0lmup8U1+RHj169OjRo/dhvXrke0lpuhc1sE3FtOfTCDfk+Yum16VHjx49evTozf29m/JRaHrdDDjVaDn1FafreTiFNV1AevTo0aNHj9585HWEqX42RLLDlthnenT7PFGQr4NL9OjRo0ePHj3rv7bo0bPoWfToWfQsehY9ehY9i55Fj55Fz6JHz6Jn0bPo/dz1Px4NXyy79PLkAAAAAElFTkSuQmCC" width="300px" height="300px"/>
     */
    get: {
      parameters: {
        query: {
          /**
           * @description GUID of a document
           * @example e7e95411-66a1-d401-e063-0a64dbb6b796
           */
          guid: string;
          /**
           * @description AES256 key in Base64 for the document
           * @example EeESAfZQh9OTf5qZhHZtgaDJpYtxZD6TIOQJzRgRFgQ=
           */
          key: string;
          /**
           * @description JWT of source integration. Can be used to pair device with the integration. Must contain `aud: "device"` claim
           * @example eyJhbGciOiJFUzI1NiJ9.eyJzdWIiOiI3OGQ5MWRlNy0xY2MyLTQwZTQtOWE3MS0zODU4YjRmMDMxOWQiLCJleHAiOjE3MTI5MDk3MjAsImp0aSI6IjAwZTAxN2Y1LTI4MTAtNDkyNS04ODRlLWNiN2FhZDAzZDFhNiIsImF1ZCI6ImRldmljZSJ9.7Op6W2BvbX2_mgj9dkz1IiolEsQ1Z2a0AzpS5bj4pcG3CJ4Z8j9W3RQE95wrAj3t6nmd9JaGZSlCJNSV_myyLQ
           */
          integration?: string;
        };
      };
      responses: {
        /** @description Redirect to app download page. The QR code / url should be open through Autogram v mobile app and parameters should be parsed and used for document signing or integration pairing. */
        302: {
          content: never;
        };
      };
    };
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    PostSignRequestBody: {
      /**
       * @description GUID of the document to sign
       * @example e1b2fafc-59c4-46de-ac0a-83aa782184e9
       */
      documentGuid: string;
      /**
       * @description AES256 encryption key in hexadecimal form (64 characters) that is used to encrypt and decrypt signing doucment.
       * @example EeESAfZQh9OTf5qZhHZtgaDJpYtxZD6TIOQJzRgRFgQ=
       */
      documentEncryptionKey: string;
    };
    PostIntegrationRequestBody: {
      /**
       * @description Platform identifier
       * @example extension
       */
      platform: string;
      /**
       * @description Human-readable name of the integration
       * @example Autogram browser extension
       */
      displayName: string;
      /**
       * @description Integration's ES256 public key that shall be used to authenticate its JWT tokens. Either with or without "-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----".
       * @example -----BEGIN PUBLIC KEY-----
       * MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEGoqUt0JPQgvvMhLNxFQkwOoClKxDK8D8oW+qmakxQuOJuy/V0uKPJbhRkEWz8WPFZCUXUr1LsD5E667h5StmLw==
       * -----END PUBLIC KEY-----
       */
      publicKey: string;
    };
    PostIntegrationResponse: {
      /**
       * @description Assigned identifier
       * @example 57820662-f56c-4b2f-97d1-e95306aee6db
       */
      guid: string;
    };
    PostDeviceRequestBody: {
      /**
       * @description Platform of the signing device used to determine which notification service to use. (`android` or `ios`)
       * @example android
       */
      platform: string;
      /**
       * @description Identifier of the app instance registration entry in the notification service (APNS or GCM)
       * @example idk32b83ef7-21fe-4120-b8fa-d9f6aba05731
       */
      registrationId: string;
      /**
       * @description Human-readable name of the device
       * @example John's phone
       */
      displayName: string;
      /**
       * @description Device's ES256 public key that shall be used to authenticate its JWT tokens. Either with or without "-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----".
       * @example -----BEGIN PUBLIC KEY-----
       * MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE1iPVm0v/ZNM04587g10F54JVIrMZqWnlOXuGjOvcYsuweTYxuXafP8aJ6kIXe+jQhjeldm2mQZzSZ4ceLRq0yA==
       * -----END PUBLIC KEY-----
       */
      publicKey: string;
      /**
       * @description Device's AES256 key in Base64 form that shall be used to encrypt notificaiton messages sent to the device
       * @example R/rfN+z129w1H2iftbr1GOKXdC3OxSJU9PZeHs+W7ts=
       */
      pushkey: string;
    };
    PostDeviceResponse: {
      /**
       * @description Assigned identifier
       * @example 03de5319-a40d-48ea-b4fb-29d11e7017bb
       */
      guid?: string;
    };
    GetDeviceIntegrationsResponseBody: {
      /**
       * @description Identifier of the integration
       * @example 0d939eb1-8e14-41e5-9c7e-05e77641cc7b
       */
      integrationId: string;
      /**
       * @description Platform identifier
       * @example extension
       */
      platform: string;
      /**
       * @description Human-readable name of the integration
       * @example Autogram browser extension
       */
      displayName: string;
    }[];
    GetIntegrationDevicesResponseBody: {
      /**
       * @description Identifier of the device
       * @example 03de5319-a40d-48ea-b4fb-29d11e7017bb
       */
      deviceId: string;
      /**
       * @description Platform of the signing device used to determine which notification service to use. (`android` or `ios`)
       * @example android
       */
      platform: string;
      /**
       * @description Human-readable name of the device
       * @example John's phone
       */
      displayName: string;
    }[];
    PostDeviceIntegrationsRequestBody: {
      /**
       * @description JWT token provided by integration on pairing. The token must contain `aud: "device"` claim.
       * @example eyJhbGciOiJFUzI1NiJ9.eyJzdWIiOiI3OGQ5MWRlNy0xY2MyLTQwZTQtOWE3MS0zODU4YjRmMDMxOWQiLCJleHAiOjE3MTI5MDk3MjAsImp0aSI6IjAwZTAxN2Y1LTI4MTAtNDkyNS04ODRlLWNiN2FhZDAzZDFhNiIsImF1ZCI6ImRldmljZSJ9.7Op6W2BvbX2_mgj9dkz1IiolEsQ1Z2a0AzpS5bj4pcG3CJ4Z8j9W3RQE95wrAj3t6nmd9JaGZSlCJNSV_myyLQ
       */
      integrationPairingToken: string;
    };
    DocumentPostRequestBody: {
      document: components["schemas"]["Document"];
      parameters?: components["schemas"]["SigningParameters"];
      /**
       * @description MIME type for document content and signature parameters XSLT transformation and XSD schema.
       * Binary files should be encoded using base64, e.g., `application/pdf;base64`.
       * Text formats like XML can be optionally encoded using base64 or supplied as plain text.
       *
       * If omitted, mimetype is decided based on document.filename and content is expected to be in Base64.
       *
       * @example text/plain;base64
       */
      payloadMimeType?: string;
    };
    /**
     * @description Base64 encoded x509 certificate of the signing entity
     * @example MIIDZjCCAk6gAwIBAgIEZVH4UzANBgkqhkiG9w0BAQsFADB1MQswCQYDVQQGEwJTSzETMBEGA1UECAwKQnJhdGlzbGF2YTETMBEGA1UEBwwKQnJhdGlzbGF2YTERMA8GA1UECgwIQXV0b2dyYW0xETAPBgNVBAsMCEF1dG9ncmFtMRYwFAYDVQQDDA1BdXRvZ3JhbSBUZXN0MB4XDTIzMTExMzEwMjAwM1oXDTI0MTExMjEwMjAwM1owdTELMAkGA1UEBhMCU0sxEzARBgNVBAgMCkJyYXRpc2xhdmExEzARBgNVBAcMCkJyYXRpc2xhdmExETAPBgNVBAoMCEF1dG9ncmFtMREwDwYDVQQLDAhBdXRvZ3JhbTEWMBQGA1UEAwwNQXV0b2dyYW0gVGVzdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN8d3eH2xRJeesoNmDIguuHBv5hhqRPsN4LGjGmhQ9NrBAN1DKW31wh0+Tfdx58GNztgLVpElpQB7/yBprqNAKADYXs+onkUbg4X798lAbiaaMvQzY9dVXhFhb1I2ZEGurNhZqP01wbjRso4O0UJ2wSIw5r/sZZji17VhdhquVzDP+RzJeU36CRohE7T1caG6Q1/Tl5arSvEcJMz/8YUYjudB0Bbj+1Z06JTWK+FW/7zJmPNsRGSnF/TLIMDvIabMDoUswP7wBPbnoWy+B/tTdKnl818OKilRlZf5mjmINvZ8I3eXl0WRA/UlURuAp3PprcZnBdejCBHNomgyML8G9sCAwEAATANBgkqhkiG9w0BAQsFAAOCAQEAKD+0fM+cRVkDOoTU9qyESQ6tma8cchjV8dVvTbvHmLTZYCBxKUTugZOz9tENd+9p+1uGc6opcCrmiHyq0oG8D8Y9FLzHFKgslod4+IHUOON/pes+r6b4/0Z4+rjuZ5JrDyeIWsGtwVQaM6BeC1afr/H7uT9kr8Eu1ElNw/SAWBmQZiz3e40XF2ijPd9b43p05O0dqBF0q383bD2K15QJofzCM+0I0OqhJwsWvHlupoPlcF4gRqFV7MUQ5QHXOryUCICp8h2O8988JFvXxaJKGMCU9Zfick3KJ3UsdJ+0jbCL4pOep75abBD6pcdD9qlUF4seiiQiceMbmmeTQfqTgg==
     */
    SigningCertificate: string;
    /**
     * @description Base64 encoded DataToSign object
     * @example MYIBBDAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMC8GCSqGSIb3DQEJBDEiBCBi60eUI/NmObmcTwDsze2zBooVmgpZh8puJa4OhNpEejCBtgYLKoZIhvcNAQkQAi8xgaYwgaMwgaAwgZ0EIJz+4gnulo5kn6oovtKTUeONdQyNjCUKINcKqCmvL7JwMHkwa6RpMGcxCzAJBgNVBAYTAlNLMRMwEQYDVQQHEwpCcmF0aXNsYXZhMRcwFQYDVQRhEw5OVFJTSy0zNTk3NTk0NjETMBEGA1UEChMKRGlzaWcgYS5zLjEVMBMGA1UEAxMMU1ZLIGVJRCBBQ0EyAgoG/pWsnJ0ABRcV
     */
    DataToSign: string;
    /**
     * @description Epoch timestamp in milliseconds of the signing time
     * @example 1707900119123
     */
    SigningTime: number;
    DataToSignRequestBody: {
      signingCertificate: components["schemas"]["SigningCertificate"];
      /**
       * @description Indication whether to add a timestamp to the signature if it was not set at document creation time
       * @default false
       * @example true
       */
      addTimestamp?: boolean;
    };
    DataToSignStructure: {
      dataToSign: components["schemas"]["DataToSign"];
      signingTime: components["schemas"]["SigningTime"];
      signingCertificate: components["schemas"]["SigningCertificate"];
    };
    SignRequestBody: {
      /**
       * @description DataToSign signed by SigningCertificate
       * @example eP49QHaKINDTo8/56O6ZlDVKGn3FYq+fRqnCMpQExYVIWrHeZkGoq2FxRRThlEKkOBUS5+8+RHZzOf4yXAFfKjNmNdMnyisEUToQqYSQavec3KZPaDgcvNdZ4MC+tRMcwTod75Zu87UleyOLe3Xoqxjteq7MvqVRCc/C1sX2yVab3yIOSgoZILpHgTl4EqTOonVJts4XBnEzuZKwXS10KyumjoSE41EqTrM/mwy95ebdrRZqNI5EWJIzor8jC5AMsmsBWvxeBKkfepFiWHMtTy1iYkJMZ6vbttlEdTSt9OqSszyw7Z7fP7Tl55hkKL4fiiXA9DOzyibn4E1XD1tRPRaqulxsdIrTbnMgeXlteXG3XXK76+OgqnRxb2hxPx6H8Qiig0GhK1Qn2H26JaNrpFjsqT9n7md9PzLuhmB4MI7HxOUCdAxmRt4cxNkJdHB2NsDBVfQ7FBNxxi35j93D/GD2KpaG77Iq/5ZfBegvQn28N2oGh/xsEqc3hoc6o23E
       */
      signedData: string;
      /** @description The original DataToSignStructre to compare it with DataToSignStructure generated in this request to verify consistency */
      dataToSignStructure: components["schemas"]["DataToSignStructure"];
    };
    SignDocumentResponseBody: {
      /**
       * @description Filename of the signed document
       * @example sample_document.pdf
       */
      filename: string;
      /**
       * @description mimeType of the signed document
       * @enum {string}
       */
      mimeType:
        | "application/pdf;base64"
        | "application/vnd.etsi.asic-e+zip;base64"
        | "application/vnd.etsi.asic-s+zip;base64";
      /**
       * @description Base64 encrypted content of the signed document
       * @example ZXhhbXBsZSBvZiBzaWduZWQgZG9jdW1lbnQgaW4gYmFzZTY0Cg==
       */
      content: string;
      /**
       * @description Distinguished name of the certificate used/attempting to sign the document.
       * @example SERIALNUMBER=PNOSK-1234567890, C=SK, L=Bratislava, SURNAME=Smith, GIVENNAME=John, CN=John Smith
       */
      signedBy: string;
      /**
       * @description Distinguished name of the issuer of the certificate used/attempting to sign the document.
       * @example CN=SVK eID ACA2, O=Disig a.s., OID.2.5.4.97=NTRSK-12345678, L=Bratislava, C=SK
       */
      issuedBy: string;
    };
    GetDocumentResponseBody: {
      /**
       * @description Filename of the signed document
       * @example sample_document.pdf
       */
      filename: string;
      /**
       * @description mimeType of the signed document
       * @enum {string}
       */
      mimeType:
        | "application/pdf;base64"
        | "application/vnd.etsi.asic-e+zip;base64"
        | "application/vnd.etsi.asic-s+zip;base64";
      /**
       * @description Base64 encrypted content of the signed document
       * @example ZXhhbXBsZSBvZiBzaWduZWQgZG9jdW1lbnQgaW4gYmFzZTY0Cg==
       */
      content: string;
      /** @description Array of all signers of the documents */
      signers?: {
        /**
         * @description Distinguished name of the certificate used/attempting to sign the document.
         * @example SERIALNUMBER=PNOSK-1234567890, C=SK, L=Bratislava, SURNAME=Smith, GIVENNAME=John, CN=John Smith
         */
        signedBy?: string;
        /**
         * @description Distinguished name of the issuer of the certificate used/attempting to sign the document.
         * @example CN=SVK eID ACA2, O=Disig a.s., OID.2.5.4.97=NTRSK-12345678, L=Bratislava, C=SK
         */
        issuedBy?: string;
      }[];
    };
    Document: {
      /**
       * @description Filename of the document. payloadMimeType must be provided if empty. Also, if payloadMimeType is empty, filename must be provided and mimetype must be understood from extension.
       * @example sample_document.txt
       */
      filename?: string;
      /**
       * @description Base64 encrypted content of the document
       * @example ZXhhbXBsZSBzdHJpbmcgaW4gYmFzZTY0Cg==
       */
      content: string;
    };
    SignatureLevelResponse: {
      /**
       * @description Signature level.
       * @example XAdES_BASELINE_B
       * @enum {string}
       */
      level?:
        | "PAdES_BASELINE_B"
        | "PAdES_BASELINE_T"
        | "XAdES_BASELINE_B"
        | "XAdES_BASELINE_T"
        | "CAdES_BASELINE_B"
        | "CAdES_BASELINE_T";
    };
    /**
     * @description Signing parameters same as in the Autogram API
     * @example {
     *   "level": "XAdES_BASELINE_B",
     *   "container": "ASiC-E"
     * }
     */
    SigningParameters: {
      /**
       * @description Check for PDF/A compliance and show warning if not compliant.
       * @default false
       */
      checkPDFACompliance?: boolean;
      /**
       * @description Try to find XSD and XSLT for a given eForm and load them automatically. Useful for visualizing and signing eForms. If true, schema, transformation, conatinerXmlns, container, packaging, and identifier parameters are ignored. If resources are not found, the response is 422. If provided document is an ASiC_E container conatining XML Datacontainer or it is an XML Datacontainer itself, XSLT found is used for visualiztion of signing document. Also, XSD and XSLT hashes are compared with hashes of XSD and XSLT found in XML Data Container EForm. If they differ, the response is 422. If the provided document is an XML document, Autogram will try to parse xmlns from root element and find resources based on its value. If successful, XML Datacontainer with xmls="http://data.gov.sk/def/container/xmldatacontainer+xml/1.1" is created, the document is validated against the XSD and visualized using the XSLT. If XSD validation fails, the response is 422. The XSLT transformation is found based on transformationLanguage (defaults to user preferred), transformationMediaDestinationTypeDescription (default XHTML, then HTML, then TXT), and transformationTargetEnvironment. If multiple transformations meet the criteria, the first one found is used.
       * @default false
       */
      autoLoadEform?: boolean;
      /**
       * @description Signature level.
       * @example XAdES_BASELINE_B
       * @enum {string}
       */
      level?:
        | "PAdES_BASELINE_B"
        | "PAdES_BASELINE_T"
        | "XAdES_BASELINE_B"
        | "XAdES_BASELINE_T"
        | "CAdES_BASELINE_B"
        | "CAdES_BASELINE_T";
      /**
       * @description Type of Advanced Signature Container. Defaults to null - no container.
       * @example ASiC-E
       * @enum {string}
       */
      container?: "ASiC-E" | "ASiC-S";
      /**
       * @description XML namespace for the XML Datacontainer. Specifies if xmldatacontainer should be created from XML. Doesn't create xmldatacontainer if payloadMimeType is application/vnd.gov.sk.xmldatacontainer+xml already. Accepts http://data.gov.sk/def/container/xmldatacontainer+xml/1.1 only. Defaults to null. Is ignored with autoLoadEform true.
       * @example http://data.gov.sk/def/container/xmldatacontainer+xml/1.1
       * @enum {string}
       */
      containerXmlns?: "http://data.gov.sk/def/container/xmldatacontainer+xml/1.1";
      /**
       * @description When creating XML Datacontainer, parameter indicates whether to embed XSD and XML or reference them. Practically this should be only used for ORSR EForms in which case (when identifier contains "justice.gov.sk/Forms") this parameter is overridden to true.
       * @example false
       */
      embedUsedSchemas?: boolean;
      /**
       * @description Optional identifier of the document template. Required if containerXmlns is http://data.gov.sk/def/container/xmldatacontainer+xml/1.1. Defaults to null. Is ignored with autoLoadEform true.
       * @example https://data.gov.sk/id/egov/eform/App.GeneralAgenda/1.9
       */
      identifier?: string;
      /**
       * @description Optional form of packaging used with XML. ENVELOPED adds the signature as a child of the root element while ENVELOPING wraps the XML in a new element. Only applies to XAdES signatures. Must be ENVELOPING when used without ASiC container and with non XML documents. Is ignored with autoLoadEform true.
       * @default ENVELOPED
       * @enum {string}
       */
      packaging?: "ENVELOPED" | "ENVELOPING";
      /**
       * @description Optional algorithm used to calculate digests.
       * @default SHA256
       * @enum {string}
       */
      digestAlgorithm?: "SHA256" | "SHA384" | "SHA512";
      /**
       * @description Optional flag to control whether the signature should be made according to ETSI EN 319132 for XAdES and ETSI EN 319122 for CAdES and PAdES.
       * @default false
       */
      en319132?: boolean;
      /**
       * @description Optional info canonicalization method.
       * @default INCLUSIVE
       * @enum {string}
       */
      infoCanonicalization?:
        | "INCLUSIVE"
        | "EXCLUSIVE"
        | "INCLUSIVE_WITH_COMMENTS"
        | "EXCLUSIVE_WITH_COMMENTS"
        | "INCLUSIVE_11"
        | "INCLUSIVE_11_WITH_COMMENTS";
      /**
       * @description Optional properties canonicalization method.
       * @default INCLUSIVE
       * @enum {string}
       */
      propertiesCanonicalization?:
        | "INCLUSIVE"
        | "EXCLUSIVE"
        | "INCLUSIVE_WITH_COMMENTS"
        | "EXCLUSIVE_WITH_COMMENTS"
        | "INCLUSIVE_11"
        | "INCLUSIVE_11_WITH_COMMENTS";
      /**
       * @description Optional key info canonicalization method.
       * @default INCLUSIVE
       * @enum {string}
       */
      keyInfoCanonicalization?:
        | "INCLUSIVE"
        | "EXCLUSIVE"
        | "INCLUSIVE_WITH_COMMENTS"
        | "EXCLUSIVE_WITH_COMMENTS"
        | "INCLUSIVE_11"
        | "INCLUSIVE_11_WITH_COMMENTS";
      /**
       * @description Optional XML schema used to validate the signing document and to compute digest used in "UsedXSDReference" in "DigestValue" attribute inside created XML Datacontainer. Format (plaintext or base64) is dictated by `payloadMimeType`. Is ignored with autoLoadEform true.
       * @example <?xml version="1.0"?><xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"><xs:element name="Document"><xs:complexType><xs:sequence><xs:element name="Title" type="xs:string" /></xs:sequence></xs:complexType></xs:element></xs:schema>
       */
      schema?: string;
      /**
       * @description Optional identifier of the XML schema. The value is used in "UsedXSDReference" field inside created XML Datacontainer. If provided with autoLoadEform true, Autogram will try to find such schema. Default value is "http://schemas.gov.sk/form/<form-idnetifier>/<version>/form.xsd".
       * @example http://schemas.gov.sk/form/App.GeneralAgenda/1.9/form.xsd
       */
      schemaIdentifier?: string;
      /**
       * @description Optional XML transformation used to present the signing document to user and to compute digest used in "UsedPresentationSchemaReference" in "DigestValue" attribute inside created XML Datacontainer. Format (plaintext or base64) is dictated by `payloadMimeType`. Is ignored with autoLoadEform true.
       * @example <?xml version="1.0"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"><xsl:template match = "/"><h1><xsl:value-of select="/Document/Title"/></h1></xsl:template></xsl:stylesheet>
       */
      transformation?: string;
      /**
       * @description Optional identifier of the XML transformation. If provided with autoLoadEform true, Autogram will try to find such transformation. Default value is "http://schemas.gov.sk/form/<form-idnetifier>/<version>/form.xslt".
       * @example http://schemas.gov.sk/form/App.GeneralAgenda/1.9/form.xslt
       */
      transformationIdentifier?: string;
      /**
       * @description Optional language of the XML transformation. If autoLoadEform is true, Autogram will try to find signing XSLT with this language. Otherwise transformation must be provided. Default value is user preferred or "sk".
       * @example sk
       */
      transformationLanguage?: string;
      /**
       * @description Optional media destination type description of the XML transformation. If autoLoadEform is true, Autogram will try to find signing XSLT with this type. Otherwise transformation must be provided. Overrides value of the output method in provided or auto-loaded transformation which is used by default.
       * @example HTML
       * @enum {string}
       */
      transformationMediaDestinationTypeDescription?: "XHTML" | "HTML" | "TXT";
      /**
       * @description Optional target environment of the XML transformation. If autoLoadEform is true, Autogram will try to find signing XSLT with this target. Otherwise transformation must be provided. Null and not used by default.
       * @example example-value
       */
      transformationTargetEnvironment?: string;
    };
    CreateDocumentResponseBody: {
      /**
       * @description GUID of the posted document
       * @example bfde97b4-ee27-47bc-97e2-5164ed96a92a
       */
      guid: string;
    };
    DocumentVisualizationResponseBody: {
      /** @example application/pdf;base64 */
      mimeType: string;
      /**
       * @description Name of the document
       * @example sample_document.pdf
       */
      filename?: string;
      /**
       * @description Base64 encoded contentto be displayed
       * @example ZXhhbXBsZSBzdHJpbmcgaW4gYmFzZTY0Cg==
       */
      content: string;
    };
    DocumentValidationResponseBody: {
      /**
       * @description Format of the validated file. ASiC_E or ASiC_S for an ASiC container. XAdES for standalone XAdES XML file and PAdES for PAdES.
       * @example ASiC_E
       * @enum {string}
       */
      fileFormat: "ASiC_E" | "ASiC_S" | "PAdES" | "XAdES";
      signatures?: {
        /**
         * @description The standard ETSI EN 319 102-1 specifies a complete validation model and procedures for the validation of “AdES digital signatures”, which are implemented in the underlying DSS module.
         * The validation result can have these values:
         *
         * "0 TOTAL_PASSED: indicating that the signature has passed verification and it complies with the signature validation policy"
         *
         * "1 TOTAL_FAILED: indicating that either the signature format is incorrect or that the digital signature value fails the verification"
         *
         * "2 INDETERMINATE: indicating that the format and digital signature verifications have not failed but there is insufficient information to determine if the electronic signature is valid"
         */
        validationResult?: {
          /**
           * @example 0
           * @enum {integer}
           */
          code?: 0 | 1 | 2;
          /**
           * @example TOTAL_PASSED
           * @enum {string}
           */
          description?: "TOTAL_PASSED" | "TOTAL_FAILED" | "INDETERMINATE";
        };
        signatureInfo?: {
          /**
           * @description Claimed signing time based on the signature only.
           * @example 2022-12-20T21:29:13 +0100
           */
          claimedSigningTime?: string;
          /**
           * @description NotAfter signing time based on the first timestamp in signature.
           * @example 2022-12-20T21:29:13 +0100
           */
          timestampSigningTime?: string;
          /**
           * @description Signature level of the signature.
           * @example XAdES_BASELINE_LTA
           * @enum {string}
           */
          level?:
            | "XAdES_BASELINE_B"
            | "XAdES_BASELINE_T"
            | "XAdES_BASELINE_LT"
            | "XAdES_BASELINE_LTA"
            | "PAdES_BASELINE_B"
            | "PAdES_BASELINE_T"
            | "PAdES_BASELINE_LT"
            | "PAdES_BASELINE_LTA"
            | "CAdES_BASELINE_B"
            | "CAdES_BASELINE_T"
            | "CAdES_BASELINE_LT"
            | "CAdES_BASELINE_LTA";
          /** @description Signing certificate details. */
          signingCertificate?: {
            /**
             * @description RFC1779 of the signing certificate issuer name.
             * @example CN=CA Disig QCA3, OU=ACA-307-2007-2, O=Disig a.s., OID.2.5.4.5=NTRSK-35975946, L=Bratislava, C=SK
             */
            issuerDN?: string;
            /**
             * @description RFC1779 of the signing certificate name.
             * @example C=SK, L=Bratislava, OID.2.5.4.5=NTRSK-30807484, O=Sociálna poisťovňa, CN=Sociálna poisťovňa
             */
            subjectDN?: string;
            /**
             * @description SerialNumber of the signing certificate.
             * @example 8.130859786708721e+22
             */
            serialNumber?: string;
            /**
             * @description Claimed signing time.
             * @example 2022-12-20T21:29:13 +0100
             */
            productionTime?: string;
            /**
             * @description The NotBefore (issuance) time of the signing certificate.
             * @example 2019-07-03T15:21:51 +0200
             */
            notBefore?: string;
            /**
             * @description The NotAfter time of the signing certificate.
             * @example 2023-07-02T15:21:51 +0200
             */
            notAfter?: string;
            /** @description Qualification of the signature at validation time. For more info check out Java class eu.europa.esig.dss.enumerations.SignatureQualification */
            qualification?: {
              /** @example 1 */
              code?: number;
              /**
               * @example QESeal
               * @enum {string}
               */
              description?:
                | "QESIG"
                | "QESEAL"
                | "UNKNOWN_QC_QSCD-QC-QSCD"
                | "ADESIG_QC-QC"
                | "ADESEAL_QC-QC"
                | "UNKNOWN_QC-QC"
                | "ADESIG"
                | "ADESEAL"
                | "UNKNOWN"
                | "INDETERMINATE_QESIG"
                | "INDETERMINATE_QESEAL"
                | "INDETERMINATE_UNKNOWN_QC_QSCD"
                | "INDETERMINATE_ADESIG_QC"
                | "INDETERMINATE_ADESEAL_QC"
                | "INDETERMINATE_UNKNOWN_QC"
                | "INDETERMINATE_ADESIG"
                | "INDETERMINATE_ADESEAL"
                | "INDETERMINATE_UNKNOWN"
                | "NOT_ADES_QC_QSCD"
                | "NOT_ADES_QC"
                | "NOT_ADES"
                | "NA";
            };
          };
          /**
           * @description Boolean indicating if the signature has any timestamp.
           * @example true
           */
          isTimestamped?: boolean;
          /** @description List of timestamps on the signature. */
          timestamps?: {
            /**
             * @description RFC1779 of the timestamp certificate issuer name.
             * @example CN=SNCA4, O=Narodna agentura pre sietove a elektronicke sluzby, OID.2.5.4.97=NTRSK-42156424, OU=SNCA, C=SK
             */
            issuerDN?: string;
            /**
             * @description RFC1779 of the timestamp certificate name.
             * @example CN=NASES Time Stamp Authority 2, O=Národná agentúra pre sieťové a elektronické služby, OID.2.5.4.97=NTRSK-42156424, OU=SNCA, C=SK
             */
            subjectDN?: string;
            /**
             * @description SerialNumber of the timestamp certificate.
             * @example 2.1220574739238914e+22
             */
            serialNumber?: string;
            /**
             * @description ProductionTime of the timestamp.
             * @example 2022-12-20T21:29:13 +0100
             */
            productionTime?: string;
            /**
             * @description The NotBefore (issuance) time of the timestamp certificate.
             * @example 2021-04-15T13:31:24 +0200
             */
            notBefore?: string;
            /**
             * @description The NotAfter time of the timestamp certificate.
             * @example 2026-04-14T13:31:24 +0200
             */
            notAfter?: string;
            /**
             * @description Qualification status fo the timestamp at validation time.
             *
             * QTSA - Qualified timestamp" - "urn:cef:dss:timestampQualification:QTSA"
             * TSA - Not qualified timestamp" - "urn:cef:dss:timestampQualification:TSA"
             * NA - Not applicable" - "urn:cef:dss:timestampQualification:notApplicable"
             */
            qualification?: {
              /**
               * @example 0
               * @enum {integer}
               */
              code?: 0 | 1 | 2;
              /**
               * @example QTSA
               * @enum {string}
               */
              description?: "QTSA" | "TSA" | "NA";
            };
            /**
             * @description Type of the timestamp
             * @example SIGNATURE_TIMESTAMP
             * @enum {string}
             */
            timestampType?:
              | "CONTENT_TIMESTAMP"
              | "ALL_DATA_OBJECTS_TIMESTAMP"
              | "INDIVIDUAL_DATA_OBJECTS_TIMESTAMP"
              | "SIGNATURE_TIMESTAMP"
              | "VRI_TIMESTAMP"
              | "VALIDATION_DATA_REFSONLY_TIMESTAMP"
              | "VALIDATION_DATA_TIMESTAMP"
              | "DOCUMENT_TIMESTAMP"
              | "ARCHIVE_TIMESTAMP";
          }[];
          signedObjectsIds?: string[];
        };
      }[];
      /** @description List of files in the container that are signed by at least one signature */
      signedObjects?: {
        /**
         * @description ID of the file used to reference the file in signatures
         * @example D-CE70D85E47F41DE68616A3695FE7569BF8F7409F052B74AE0356663393A68D8A
         */
        id?: string;
        /**
         * @description MimeType of the file
         * @example text/xml
         */
        mimeType?: string;
        /**
         * @description Filename of the file in the container. If the validated document is PAdES or standalone XAdES where filename is unknown, this attribute should be ignored.
         * @example form.xml
         */
        filename?: string;
      }[];
      /** @description List of files in the container that have not been referenced in any signature yet */
      unsignedObjects?: {
        /**
         * @description MimeType of the file
         * @example application/pdf
         */
        mimeType?: string;
        /**
         * @description Filename of the file in the container. If the validated document is PAdES or standalone XAdES where filename is unknown, this attribute should be ignored.
         * @example Some_unsigned_document.pdf
         */
        filename?: string;
      }[];
    };
    BadRequestErrorResponseBody: {
      /**
       * @description Code that can be used to identify the error.
       * @example BAD_REQUEST
       */
      code: string;
      /**
       * @description Human readable error message.
       * @example Parameter missing.
       */
      message: string;
      /**
       * @description Optional details.
       * @example Document ID is missing in request.
       */
      details?: string;
    };
    ErrorResponseBody: {
      /**
       * @description Code that can be used to identify the error.
       *
       * `MULTIPLE_ORIGINAL_DOCUMENTS` will be removed in the future possibly.
       *
       * `DATATOSIGN_MISMATCH` applies to `/sign` request only.
       *
       * `CERTIFICATE_NOT_VALID` applies to `/datatosign` and `/sign` requests only.
       *
       * @enum {string}
       */
      code:
        | "UNPROCESSABLE_INPUT"
        | "UNSUPPORTED_SIGNATURE_LEVEL"
        | "MULTIPLE_ORIGINAL_DOCUMENTS"
        | "ORIGINAL_DOCUMENT_NOT_FOUND"
        | "MALFORMED_INPUT"
        | "EMPTY_BODY"
        | "DATATOSIGN_MISMATCH"
        | "CERTIFICATE_NOT_VALID"
        | "FAILED_PARSING_MIMETYPE";
      /**
       * @description Human readable error message.
       * @example IllegalArgumentException parsing request body
       */
      message: string;
      /**
       * @description Optional details.
       * @example Document must be a PDF when using PAdES.
       */
      details?: string;
    };
    EncryptionKeyNotProvidedErrorResponseBody: {
      /**
       * @description Code that can be used to identify the error.
       * @enum {string}
       */
      code: "ENCRYPTION_KEY_MISSING" | "ENCRYPTION_KEY_MALFORMED";
      /**
       * @description Human readable error message.
       * @example Encryption key not provided.
       */
      message: string;
      /**
       * @description Optional details.
       * @example Encryption key must be provided either in X-Encryption-Key header or as encryptionKey query parameter.
       */
      details?: string;
    };
    EncryptionKeyMismatchErrorResponseBody: {
      /**
       * @description Code that can be used to identify the error.
       * @enum {string}
       */
      code: "ENCRYPTION_KEY_MISMATCH";
      /**
       * @description Human readable error message.
       * @example Encryption key mismatch.
       */
      message: string;
      /**
       * @description Optional details.
       * @example Provided encryption key failed to decrypt document.
       */
      details?: string;
    };
    InternalErrorResponseBody: {
      /**
       * @description Code that can be used to identify the error.
       * @enum {string}
       */
      code: "INTERNAL_ERROR";
      /**
       * @description Human readable error message.
       * @example Unexpected error while signing document.
       */
      message: string;
      /**
       * @description Optional details.
       * @example Something unexpected happened.
       */
      details?: string;
    };
    BadGatewayErrorResponseBody: {
      /**
       * @description Code that can be used to identify the error.
       * @enum {string}
       */
      code: "UNRECOGNIZED_DSS_ERROR" | "SIGNING_FAILED" | "INTERNAL_ERROR";
      /**
       * @description Human readable error message.
       * @example Unexpected error while signing document.
       */
      message: string;
      /**
       * @description Optional details.
       * @example Something unexpected happened.
       */
      details?: string;
    };
    InvalidSignatureErrorResponseBody: {
      /**
       * @description Code that can be used to identify the error.
       *
       * `INVALID_SIGNATURE_VALUE` - the `signedData` sent by client are not corresponding with dataToSign and certificate.
       *
       * `SIGNATURE_NOT_IN_TACT` - signature value is not valid for the signed document.
       *
       * @enum {string}
       */
      code: "INVALID_SIGNATURE_VALUE" | "SIGNATURE_NOT_IN_TACT";
      /**
       * @description Human readable error message.
       * @example Created signature is not valid.
       */
      message: string;
      /**
       * @description Optional details.
       * @example The signed data were not signed by the provided certificate.
       */
      details?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export type operations = Record<string, never>;
